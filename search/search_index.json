{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> <p> </p> <p> </p> <p></p> <p></p>"},{"location":"#pydantic-factories","title":"Pydantic-Factories","text":"<p>This library offers powerful mock data generation capabilities for pydantic based models and <code>dataclasses</code>. It can also be used with other libraries that use pydantic as a foundation.</p>"},{"location":"#example","title":"Example","text":"<pre><code>from datetime import date, datetime\nfrom typing import List, Union\nfrom pydantic import BaseModel, UUID4\nfrom pydantic_factories import ModelFactory\nclass Person(BaseModel):\nid: UUID4\nname: str\nhobbies: List[str]\nage: Union[float, int]\nbirthday: Union[datetime, date]\nclass PersonFactory(ModelFactory):\n__model__ = Person\nresult = PersonFactory.build()\n</code></pre> <p>That's it - with almost no work, we are able to create a mock data object fitting the <code>Person</code> class model definition.</p> <p>This is possible because of the typing information available on the pydantic model and model-fields, which are used as a source of truth for data generation.</p> <p>The factory parses the information stored in the pydantic model and generates a dictionary of kwargs that are passed to the <code>Person</code> class' init method.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pydantic-factories\n</code></pre>"},{"location":"usage/0-build-methods/","title":"Build Methods","text":"<p>The <code>ModelFactory</code> class exposes two build methods:</p> <ul> <li><code>.build(**kwargs)</code> - builds a single instance of the factory's model</li> <li><code>.batch(size: int, **kwargs)</code> - build a list of size n instances</li> </ul> <pre><code>from pydantic import BaseModel\nfrom pydantic_factories import ModelFactory\nclass Person(BaseModel):\n...\nclass PersonFactory(ModelFactory):\n__model__ = Person\nsingle_result = PersonFactory.build()  # a single Person instance\nbatch_result = PersonFactory.batch(\nsize=5\n)  # list[Person, Person, Person, Person, Person]\n</code></pre> <p>Any <code>kwargs</code> you pass to <code>.build</code>, <code>.batch</code> or any of the persistence methods, will take precedence over whatever defaults are defined on the factory class itself.</p> <p>By default, when building a pydantic class, kwargs are validated, to avoid input validation you can use the <code>factory_use_construct</code> param.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_factories import ModelFactory\nclass Person(BaseModel):\n...\nclass PersonFactory(ModelFactory):\n__model__ = Person\nPersonFactory.build(id=5)  # Raises a validation error\nresult = PersonFactory.build(\nfactory_use_construct=True, id=5\n)  # Build a Person with invalid id\n</code></pre>"},{"location":"usage/0-build-methods/#partial-parameters","title":"Partial Parameters","text":"<p>Factories can randomly generate missing parameters for child factories. For example:</p> <pre><code>from pydantic_factories import ModelFactory\nfrom pydantic import BaseModel\nclass Pet(BaseModel):\nname: str\nage: int\nclass Person(BaseModel):\nname: str\npets: list[Pet]\nage: int\nclass PersonFactory(ModelFactory[Person]):\n__model__ = Person\n</code></pre> <p>When building a person without specifying the Person and pets ages, all these fields will be randomly generated:</p> <pre><code>from pydantic_factories import ModelFactory\nfrom pydantic import BaseModel\nclass Pet(BaseModel):\nname: str\nage: int\nclass Person(BaseModel):\nname: str\npets: list[Pet]\nage: int\nclass PersonFactory(ModelFactory[Person]):\n__model__ = Person\ndata = {\n\"name\": \"John\",\n\"pets\": [\n{\"name\": \"dog\"},\n{\"name\": \"cat\"},\n],\n}\nperson = PersonFactory.build(**data)\nprint(person.json(indent=2))\n</code></pre> <pre><code>{\n\"name\": \"John\",\n\"pets\": [\n{\n\"name\": \"dog\",\n\"age\": 9005\n},\n{\n\"name\": \"cat\",\n\"age\": 2455\n}\n],\n\"age\": 975\n}\n</code></pre>"},{"location":"usage/1-nest-models/","title":"Nested Models","text":"<p>The automatic generation of mock data works for all types supported by pydantic, as well as nested classes that derive from <code>BaseModel</code> (including for 3rd party libraries) and complex types. Let's look at another example:</p> <pre><code>from datetime import date, datetime\nfrom enum import Enum\nfrom pydantic import BaseModel, UUID4\nfrom typing import Any, Dict, List, Union\nfrom pydantic_factories import ModelFactory\nclass Species(str, Enum):\nCAT = \"Cat\"\nDOG = \"Dog\"\nPIG = \"Pig\"\nMONKEY = \"Monkey\"\nclass Pet(BaseModel):\nname: str\nsound: str\nspecies: Species\nclass Person(BaseModel):\nid: UUID4\nname: str\nhobbies: List[str]\nage: Union[float, int]\nbirthday: Union[datetime, date]\npets: List[Pet]\nassets: List[Dict[str, Dict[str, Any]]]\nclass PersonFactory(ModelFactory):\n__model__ = Person\nresult = PersonFactory.build()\n</code></pre> <p>This example will also work out of the box although no factory was defined for the Pet class, that's not a problem - a factory will be dynamically generated for it on the fly.</p> <p>The complex typing under the <code>assets</code> attribute is a bit more tricky, but the factory will generate a python object fitting this signature, therefore passing validation.</p> <p>Please note: the one thing factories cannot handle is self referencing models, because this can lead to recursion errors. In this case you will need to handle the particular field by setting defaults for it.</p>"},{"location":"usage/2-dataclasses/","title":"Supported Models","text":"<p>This library works with any class that inherits the pydantic <code>BaseModel</code> class, including <code>GenericModel</code> and classes from 3rd party libraries, and also with dataclasses - both those from the python standard library and pydantic's dataclasses. Finally, it also supports <code>TypedDict</code> classes. In fact, you can use them interchangeably as you like:</p> <pre><code>import dataclasses\nfrom typing import Dict, List\nimport pydantic\nfrom pydantic_factories import ModelFactory\n@pydantic.dataclasses.dataclass\nclass MyPydanticDataClass:\nname: str\nclass MyFirstModel(pydantic.BaseModel):\ndataclass: MyPydanticDataClass\n@dataclasses.dataclass()\nclass MyPythonDataClass:\nid: str\ncomplex_type: Dict[str, Dict[int, List[MyFirstModel]]]\nclass MySecondModel(pydantic.BaseModel):\ndataclasses: List[MyPythonDataClass]\nclass MyFactory(ModelFactory):\n__model__ = MySecondModel\nresult = MyFactory.build()\n</code></pre> <p>The above example will build correctly.</p>"},{"location":"usage/2-dataclasses/#note-regarding-nested-optional-types-in-dataclasses","title":"Note Regarding Nested Optional Types in Dataclasses","text":"<p>When generating mock values for fields typed as <code>Optional</code>, if the factory is defined with <code>__allow_none_optionals__ = True</code>, the field value will be either a value or None - depending on a random decision. This works even when the <code>Optional</code> typing is deeply nested, except for dataclasses - typing is only shallowly evaluated for dataclasses, and as such they are always assumed to require a value. If you wish to have a None value, in this particular case, you should do so manually by configured a <code>Use</code> callback for the particular field.</p>"},{"location":"usage/3-configuration/","title":"Factory Configuration","text":"<p>Configuration of <code>ModelFactory</code> is done using class variables:</p> <ul> <li> <p>__model__: a required variable specifying the model for the factory. It accepts any class that extends _   pydantic's_ <code>BaseModel</code> including classes from other libraries. If this variable is not set,   a <code>ConfigurationException</code> will be raised.</p> </li> <li> <p>__faker__: an optional variable specifying a user configured instance of faker. If this variable is not set,   the factory will default to using vanilla <code>faker</code>.</p> </li> <li> <p>__sync_persistence__: an optional variable specifying the handler for synchronously persisting data. If this   is variable is not set, the <code>.create_sync</code> and <code>.create_batch_sync</code> methods of the factory cannot be used.   See: persistence methods</p> </li> <li> <p>__async_persistence__: an optional variable specifying the handler for asynchronously persisting data. If   this is variable is not set, the <code>.create_async</code> and <code>.create_batch_async</code> methods of the factory cannot be used.   See: persistence methods</p> </li> <li> <p>__allow_none_optionals__: an optional variable specifying whether the factory should randomly set None   values for optional fields, or always set a value for them. This is <code>True</code> by default.</p> </li> </ul> <pre><code>from faker import Faker\nfrom pydantic_factories import ModelFactory\nfrom app.models import Person\nfrom .persistence import AsyncPersistenceHandler, SyncPersistenceHandler\nFaker.seed(5)\nmy_faker = Faker(\"en-EN\")\nclass PersonFactory(ModelFactory):\n__model__ = Person\n__faker__ = my_faker\n__sync_persistence__ = SyncPersistenceHandler\n__async_persistence__ = AsyncPersistenceHandler\n__allow_none_optionals__ = False\n...\n</code></pre>"},{"location":"usage/3-configuration/#generating-deterministic-objects","title":"Generating deterministic objects","text":"<p>In order to generate deterministic data, use <code>ModelFactory.seed_random</code> method. This will pass the seed value to both Faker and random method calls, guaranteeing data to be the same in between the calls. Especially useful for testing.</p>"},{"location":"usage/4-defining-factory-fields/","title":"Defining Factory Fields","text":"<p>The factory api is designed to be as semantic and simple as possible, lets look at several examples that assume we have the following models:</p> <pre><code>from datetime import date, datetime\nfrom enum import Enum\nfrom pydantic import BaseModel, UUID4\nfrom typing import Any, Dict, List, Union\nfrom pydantic_factories import ModelFactory\nclass Species(str, Enum):\nCAT = \"Cat\"\nDOG = \"Dog\"\nclass Pet(BaseModel):\nname: str\nspecies: Species\nclass Person(BaseModel):\nid: UUID4\nname: str\nhobbies: List[str]\nage: Union[float, int]\nbirthday: Union[datetime, date]\npets: List[Pet]\nassets: List[Dict[str, Dict[str, Any]]]\npet = Pet(name=\"Roxy\", sound=\"woof woof\", species=Species.DOG)\nclass PersonFactory(ModelFactory):\n__model__ = Person\npets = [pet]\n</code></pre> <p>In this case when we call <code>PersonFactory.build()</code> the result will be randomly generated, except the pets list, which will be the hardcoded default we defined.</p>"},{"location":"usage/4-defining-factory-fields/#use","title":"Use","text":"<p>This though is often not desirable. We could instead, define a factory for <code>Pet</code> where we restrict the choices to a range we like. For example:</p> <pre><code>from datetime import date, datetime\nfrom pydantic import BaseModel, UUID4\nfrom typing import Any, Dict, List, Union\nfrom enum import Enum\nfrom pydantic_factories import ModelFactory, Use\nfrom random import choice\nclass Species(str, Enum):\nCAT = \"Cat\"\nDOG = \"Dog\"\nclass Pet(BaseModel):\nname: str\nspecies: Species\nclass Person(BaseModel):\nid: UUID4\nname: str\nhobbies: List[str]\nage: Union[float, int]\nbirthday: Union[datetime, date]\npets: List[Pet]\nassets: List[Dict[str, Dict[str, Any]]]\nclass PetFactory(ModelFactory):\n__model__ = Pet\nname = Use(choice, [\"Ralph\", \"Roxy\"])\nspecies = Use(choice, list(Species))\nclass PersonFactory(ModelFactory):\n__model__ = Person\npets = Use(PetFactory.batch, size=2)\n</code></pre> <p>The signature for use is: <code>cb: Callable, *args, **defaults</code>, it can receive any sync callable. In the above example, we used the <code>choice</code> function from the standard library's <code>random</code> package, and the batch method of <code>PetFactory</code>.</p> <p>You do not need to use the <code>Use</code> field, you can place callables (including classes) as values for a factory's attribute directly, and these will be invoked at build-time. Thus, you could for example re-write the above <code>PetFactory</code> like so:</p> <pre><code>from enum import Enum\nfrom pydantic import BaseModel\nfrom random import choice\nfrom pydantic_factories import ModelFactory\nclass Species(str, Enum):\nCAT = \"Cat\"\nDOG = \"Dog\"\nclass Pet(BaseModel):\nname: str\nspecies: Species\nclass PetFactory(ModelFactory):\n__model__ = Pet\nname = lambda: choice([\"Ralph\", \"Roxy\"])  # noqa: E731\nspecies = lambda: choice(list(Species))  # noqa: E731\n</code></pre> <p><code>Use</code> is merely a semantic abstraction that makes the factory cleaner and simpler to understand.</p>"},{"location":"usage/4-defining-factory-fields/#global-factory-registration","title":"Global factory registration","text":"<p>Sometimes you want to alter how a model is built by default. It is especially useful for a model that is used a lot across the project. In this case updating attributes to reference specific factory everywhere can be quite cumbersome. Instead you can rely on auto registering models by setting the <code>__auto_register__</code> attribute`.</p> <pre><code>from datetime import date, datetime\nfrom pydantic import BaseModel, UUID4\nfrom typing import Any, Dict, List, Union\nfrom enum import Enum\nfrom pydantic_factories import ModelFactory\nfrom random import choice\nclass Species(str, Enum):\nCAT = \"Cat\"\nDOG = \"Dog\"\nclass Pet(BaseModel):\nname: str\nspecies: Species\nclass Person(BaseModel):\nid: UUID4\nname: str\nhobbies: List[str]\nage: Union[float, int]\nbirthday: Union[datetime, date]\npets: List[Pet]\nassets: List[Dict[str, Dict[str, Any]]]\nclass PetFactory(ModelFactory):\n__model__ = Pet\n__auto_register__ = True\nname = lambda: choice([\"Ralph\", \"Roxy\"])  # noqa: E731\nspecies = Species.DOG\nclass PersonFactory(ModelFactory):\n__model__ = Person\n</code></pre> <p>Here if we call <code>PersonFactory.build()</code> the result will be randomly generated except the pet list which will contain a dog with the name <code>Ralph</code> or <code>Roxy</code>. Notice that in this case we didn't have to define the <code>pets</code> attribute in the <code>PersonFactory</code> because we have registered <code>PetFactory</code> as the default factory for the <code>Pet</code> model.</p>"},{"location":"usage/4-defining-factory-fields/#postgenerated","title":"PostGenerated","text":"<p>It allows for post generating fields based on already generated values of other (non post generated) fields. In most cases this pattern is best avoided, but for the few valid cases the <code>PostGenerated</code> helper is provided. For example:</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_factories import ModelFactory, PostGenerated\nfrom random import randint\nfrom datetime import datetime, timedelta\ndef add_timedelta(name: str, values: dict, *args, **kwds):\ndelta = timedelta(days=randint(0, 12), seconds=randint(13, 13000))\nreturn values[\"from_dt\"] + delta\nclass MyModel(BaseModel):\nfrom_dt: datetime\nto_dt: datetime\nclass MyFactory(ModelFactory):\n__model__ = MyModel\nto_dt = PostGenerated(add_timedelta)\n</code></pre> <p>The signature for use is: <code>cb: Callable, *args, **defaults</code>, it can receive any sync callable. The signature for the callable should be: <code>name: str, values: dict[str, Any], *args, **defaults</code>. The already generated values are mapped by name in the <code>values</code> dictionary.</p>"},{"location":"usage/4-defining-factory-fields/#ignore","title":"Ignore","text":"<p><code>Ignore</code> is another field exported by this library, and its used - as its name implies - to designate a given attribute as ignored:</p> <pre><code>from typing import TypeVar\nfrom odmantic import EmbeddedModel, Model\nfrom pydantic_factories import ModelFactory, Ignore\nT = TypeVar(\"T\", Model, EmbeddedModel)\nclass OdmanticModelFactory(ModelFactory[T]):\nid = Ignore()\n</code></pre> <p>The above example is basically the extension included in <code>pydantic-factories</code> for the library ODMantic, which is a pydantic based mongo ODM.</p> <p>For ODMantic models, the <code>id</code> attribute should not be set by the factory, but rather handled by the odmantic logic itself. Thus, the <code>id</code> field is marked as ignored.</p> <p>When you ignore an attribute using <code>Ignore</code>, it will be completely ignored by the factory - that is, it will not be set as a kwarg passed to pydantic at all.</p>"},{"location":"usage/4-defining-factory-fields/#require","title":"Require","text":"<p>The <code>Require</code> field in turn specifies that a particular attribute is a required kwarg. That is, if a kwarg with a value for this particular attribute is not passed when calling <code>factory.build()</code>, a <code>MissingBuildKwargError</code> will be raised.</p> <p>What is the use case for this? For example, lets say we have a document called <code>Article</code> which we store in some DB and is represented using a non-pydantic model, say, an <code>elastic-dsl</code> document. We then need to store in our pydantic object a reference to an id for this article. This value should not be some mock value, but must rather be an actual id passed to the factory. Thus, we can define this attribute as required:</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_factories import ModelFactory, Require\nfrom uuid import UUID\nclass ArticleProxy(BaseModel):\narticle_id: UUID\n...\nclass ArticleProxyFactory(ModelFactory):\n__model__ = ArticleProxy\narticle_id = Require()\n</code></pre> <p>If we call <code>factory.build()</code> without passing a value for article_id, an error will be raised.</p>"},{"location":"usage/4-defining-factory-fields/#fixture","title":"Fixture","text":"<p>The <code>Fixture</code> field is a special field meant to be used with factories that have been decorated using register_fixture. For example:</p> <pre><code>from typing import Optional, List, Union\nfrom datetime import datetime, date\nfrom pydantic import BaseModel, UUID4\nfrom pydantic_factories import ModelFactory, Fixture\nfrom pydantic_factories.plugins.pytest_plugin import register_fixture\nclass Person(BaseModel):\nid: UUID4\nname: str\nhobbies: Optional[List[str]]\nnicks: List[str]\nage: Union[float, int]\nbirthday: Union[datetime, date]\nclass ClassRoom(BaseModel):\nteacher: Person\npupils: List[Person]\n@register_fixture(name=\"my_fixture\")\nclass PersonFactory(ModelFactory):\n__model__ = Person\nclass ClassRoomFactory(ModelFactory):\nteacher = Fixture(PersonFactory, name=\"Jenny Osterman\")\npupils = Fixture(PersonFactory, size=20)\n</code></pre> <p>If we tried to use <code>PersonFactory</code> now normally it wouldn't work because pytest fixtures can only be called by pytest. Thus we can use <code>Fixture</code>. As you can see above, this field can accept kwargs that are passed to the factory's underlying build or batch methods, and an optional <code>size</code> kwarg. If <code>size</code> is given, than a batch is returned, otherwise the normal build method is used.</p>"},{"location":"usage/5-persistence/","title":"Persistence","text":"<p><code>ModelFactory</code> has four persistence methods:</p> <ul> <li><code>.create_sync(**kwargs)</code> - builds and persists a single instance of the factory's model synchronously</li> <li><code>.create_batch_sync(size: int, **kwargs)</code> - builds and persists a list of size n instances synchronously</li> <li><code>.create_async(**kwargs)</code> - builds and persists a single instance of the factory's model asynchronously</li> <li><code>.create_batch_async(size: int, **kwargs)</code> - builds and persists a list of size n instances asynchronously</li> </ul> <p>To use these methods, you must first specify a sync and/or async persistence handlers for the factory:</p> <pre><code>from pydantic_factories import ModelFactory\nfrom typing import TypeVar, List\nfrom pydantic import BaseModel\nfrom pydantic_factories import SyncPersistenceProtocol, AsyncPersistenceProtocol\nT = TypeVar(\"T\", bound=BaseModel)\nclass SyncPersistenceHandler(SyncPersistenceProtocol[T]):\ndef save(self, data: T) -&gt; T:\n...  # do stuff\ndef save_many(self, data: List[T]) -&gt; List[T]:\n...  # do stuff\nclass AsyncPersistenceHandler(AsyncPersistenceProtocol[T]):\nasync def save(self, data: T) -&gt; T:\n...  # do stuff\nasync def save_many(self, data: List[T]) -&gt; List[T]:\n...  # do stuff\nclass PersonFactory(ModelFactory):\n__sync_persistence__ = SyncPersistenceHandler\n__async_persistence__ = AsyncPersistenceHandler\n...\n</code></pre> <p>Or create your own base factory and reuse it in your various factories:</p> <pre><code>from pydantic_factories import ModelFactory\nfrom typing import TypeVar, List\nfrom pydantic import BaseModel\nfrom pydantic_factories import SyncPersistenceProtocol, AsyncPersistenceProtocol\nT = TypeVar(\"T\", bound=BaseModel)\nclass SyncPersistenceHandler(SyncPersistenceProtocol[T]):\ndef save(self, data: T) -&gt; T:\n...  # do stuff\ndef save_many(self, data: List[T]) -&gt; List[T]:\n...  # do stuff\nclass AsyncPersistenceHandler(AsyncPersistenceProtocol[T]):\nasync def save(self, data: T) -&gt; T:\n...  # do stuff\nasync def save_many(self, data: List[T]) -&gt; List[T]:\n...  # do stuff\nclass BaseModelFactory(ModelFactory):\n__sync_persistence__ = SyncPersistenceHandler\n__async_persistence__ = AsyncPersistenceHandler\nclass PersonFactory(BaseModelFactory):\n...\n</code></pre> <p>With the persistence handlers in place, you can now use all persistence methods. Please note - you do not need to define any or both persistence handlers. If you will only use sync or async persistence, you only need to define the respective handler to use these methods.</p>"},{"location":"usage/5-persistence/#create-factory-method","title":"Create Factory Method","text":"<p>If you prefer to create a factory imperatively, you can do so using the <code>ModelFactory.create_factory</code> method. This method receives the following arguments:</p> <ul> <li>model - the model for the factory.</li> <li>base - an optional base factory class. Defaults to the factory class on which the method is called.</li> <li>kwargs - a dictionary of arguments correlating to the class vars accepted by ModelFactory, e.g. faker.</li> </ul> <p>You could also override the child factory's <code>__model__</code> attribute to specify the model to use and the default kwargs as shown as the BuildPet class as shown below:</p> <pre><code>from datetime import date, datetime\nfrom enum import Enum\nfrom pydantic import BaseModel, UUID4\nfrom typing import Any, Dict, List, TypeVar, Union, Generic, Optional\nfrom pydantic_factories import ModelFactory\nclass Species(str, Enum):\nCAT = \"Cat\"\nDOG = \"Dog\"\nclass PetBase(BaseModel):\nname: str\nspecies: Species\nclass Pet(PetBase):\nid: UUID4\nclass PetCreate(PetBase):\npass\nclass PetUpdate(PetBase):\npass\nclass PersonBase(BaseModel):\nname: str\nhobbies: List[str]\nage: Union[float, int]\nbirthday: Union[datetime, date]\npets: List[Pet]\nassets: List[Dict[str, Dict[str, Any]]]\nclass PersonCreate(PersonBase):\npass\nclass Person(PersonBase):\nid: UUID4\nclass PersonUpdate(PersonBase):\npass\ndef test_factory():\nclass PersonFactory(ModelFactory):\n__model__ = Person\nperson = PersonFactory.build()\nassert person.pets != []\nModelType = TypeVar(\"ModelType\", bound=BaseModel)\nCreateSchemaType = TypeVar(\"CreateSchemaType\", bound=BaseModel)\nUpdateSchemaType = TypeVar(\"UpdateSchemaType\", bound=BaseModel)\nclass BUILDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):\ndef __init__(\nself,\nmodel: ModelType = None,\ncreate_schema: Optional[CreateSchemaType] = None,\nupdate_schema: Optional[UpdateSchemaType] = None,\n):\nself.model = model\nself.create_model = create_schema\nself.update_model = update_schema\ndef build_object(self) -&gt; ModelType:\nobject_Factory = ModelFactory.create_factory(self.model)\nreturn object_Factory.build()\ndef build_create_object(self) -&gt; CreateSchemaType:\nobject_Factory = ModelFactory.create_factory(self.create_model)\nreturn object_Factory.build()\ndef build_update_object(self) -&gt; UpdateSchemaType:\nobject_Factory = ModelFactory.create_factory(self.update_model)\nreturn object_Factory.build()\nclass BUILDPet(BUILDBase[Pet, PetCreate, PetUpdate]):\ndef build_object(self) -&gt; Pet:\nobject_Factory = ModelFactory.create_factory(self.model, name=\"Fido\")\nreturn object_Factory.build()\ndef build_create_object(self) -&gt; PetCreate:\nobject_Factory = ModelFactory.create_factory(self.create_model, name=\"Rover\")\nreturn object_Factory.build()\ndef build_update_object(self) -&gt; PetUpdate:\nobject_Factory = ModelFactory.create_factory(self.update_model, name=\"Spot\")\nreturn object_Factory.build()\ndef test_factory_create():\nperson_factory = BUILDBase(Person, PersonCreate, PersonUpdate)\npet_factory = BUILDPet(Pet, PetCreate, PetUpdate)\ncreate_person = person_factory.build_create_object()\nupdate_person = person_factory.build_update_object()\npet = pet_factory.build_object()\ncreate_pet = pet_factory.build_create_object()\nupdate_pet = pet_factory.build_update_object()\nassert create_person is not None\nassert update_person is not None\nassert pet.name == \"Fido\"\nassert create_pet.name == \"Rover\"\nassert update_pet.name == \"Spot\"\n</code></pre>"},{"location":"usage/6-extensions/","title":"Extensions","text":"<p>Any class that is derived from pydantic's <code>BaseModel</code> can be used as the <code>__model__</code> of a factory. For most 3rd party libraries, e.g. SQLModel, this library will work as is out of the box.</p> <p>Currently, this library also includes the following extensions:</p>"},{"location":"usage/6-extensions/#odmantic","title":"ODMantic","text":"<p>This extension includes a class called <code>OdmanticModelFactory</code> and it can be imported from <code>pydantic_factory.extensions</code>. This class is meant to be used with the <code>Model</code> and <code>EmbeddedModel</code> classes exported by ODMantic, but it will also work with regular instances of pydantic's <code>BaseModel</code>.</p>"},{"location":"usage/6-extensions/#beanie","title":"Beanie","text":"<p>This extension includes a class called <code>BeanieDocumentFactory</code> as well as an <code>BeaniePersistenceHandler</code>. Both of these can be imported from <code>pydantic_factory.extensions</code>. The <code>BeanieDocumentFactory</code> is meant to be used with the Beanie <code>Document</code> class, and it includes async persistence build in.</p>"},{"location":"usage/6-extensions/#ormar","title":"Ormar","text":"<p>This extension includes a class called <code>OrmarModelFactory</code>. This class is meant to be used with the <code>Model</code> class exported by ormar.</p>"},{"location":"usage/7-handling-custom-types/","title":"Handling Custom Types","text":"<p>If your model has an attribute that is not supported by <code>pydantic-factories</code> and it depends on third party libraries, you can create your custom extension subclassing the <code>ModelFactory</code>, and overriding the <code>get_mock_value</code> method to add your logic.</p> <pre><code>from typing import Any\nfrom pydantic_factories import ModelFactory\nclass CustomFactory(ModelFactory[Any]):\n\"\"\"Tweak the ModelFactory to add our custom mocks.\"\"\"\n@classmethod\ndef get_mock_value(cls, field_type: Any) -&gt; Any:\n\"\"\"Add our custom mock value.\"\"\"\nif str(field_type) == \"my_super_rare_datetime_field\":\nreturn cls.get_faker().date_time_between()\nreturn super().get_mock_value(field_type)\n</code></pre> <p>Where <code>cls.get_faker()</code> is a <code>faker</code> instance that you can use to build your returned value.</p>"},{"location":"usage/8-pytest-fixtures/","title":"Using Factories as Fixtures","text":"<p>Any class from <code>ModelFactory</code> can use the decorator to register as a fixture easily.</p> <p>The model factory will be registered as a fixture with the name in snake case.</p> <p>e.g. <code>PersonFactory</code> -&gt; <code>person_factory</code></p> <p>The decorator also provides some pytest-like arguments to define the fixture. (<code>scope</code>, <code>autouse</code>, <code>name</code>)</p> <pre><code>from datetime import date, datetime\nfrom typing import List, Union\nfrom pydantic import UUID4, BaseModel\nfrom pydantic_factories import ModelFactory\nfrom pydantic_factories.plugins.pytest_plugin import register_fixture\nclass Person(BaseModel):\nid: UUID4\nname: str\nhobbies: List[str]\nage: Union[float, int]\nbirthday: Union[datetime, date]\n@register_fixture\nclass PersonFactory(ModelFactory):\n\"\"\"A person factory\"\"\"\n__model__ = Person\n@register_fixture(scope=\"session\", autouse=True, name=\"cool_guy_factory\")\nclass AnotherPersonFactory(ModelFactory):\n\"\"\"A cool guy factory\"\"\"\n__model__ = Person\ndef test_person_factory(person_factory: PersonFactory) -&gt; None:\nperson = person_factory.build()\nassert isinstance(person, Person)\ndef test_cool_guy_factory(cool_guy_factory: AnotherPersonFactory) -&gt; None:\ncool_guy = cool_guy_factory.build()\nassert isinstance(cool_guy, Person)\n</code></pre> <p>Use <code>pytest --fixtures</code> will show output along these lines:</p> <pre><code>------------- fixtures defined from pydantic_factories.plugins.pytest_plugin -------------\ncool_guy_factory [session scope] -- pydantic_factories/plugins/pytest_plugin.py:48\n    A cool guy factory\n\nperson_factory -- pydantic_factories/plugins/pytest_plugin.py:48\n    A person factory\n</code></pre>"}]}